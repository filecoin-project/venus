package gen

import (
	"fmt"
	"io"
)

// IpldCborTypeEncodingGenerator generates encoding/decoding implementations for the IpldCbor encoding.
//
// This code generator only works with the IpldCborEncoder/IpldCborDecoder pair
// and is intended as an intermediate step towards a pure CBOR encoder/decoder.
type IpldCborTypeEncodingGenerator struct {
}

var useReflection = true

// WriteImports outputs the imports.
func (generator IpldCborTypeEncodingGenerator) WriteImports(w io.Writer) error {
	if useReflection {
		return doTemplate(w, nil, `
import (
	"github.com/filecoin-project/go-filecoin/internal/pkg/encoding"
)
`)
	}

	return doTemplate(w, nil, `
import (
	"github.com/filecoin-project/go-filecoin/internal/pkg/encoding"
	"github.com/polydawn/refmt/obj/atlas"
)
`)
}

// WriteInit outputs the init for the file.
func (generator IpldCborTypeEncodingGenerator) WriteInit(w io.Writer, tis []TypeInfo) error {
	if _, err := fmt.Fprintln(w, "\nfunc init() {"); err != nil {
		return err
	}

	for _, ti := range tis {
		if useReflection {
			if _, err := fmt.Fprintf(w, "    encoding.RegisterIpldCborType(%s{})\n", ti.Name); err != nil {
				return err
			}
		} else {
			if _, err := fmt.Fprintf(w, "    encoding.RegisterIpldCborType(atlasEntry_%s)\n", ti.Name); err != nil {
				return err
			}
		}

	}

	if _, err := fmt.Fprintln(w, "}"); err != nil {
		return err
	}

	return nil
}

// WriteEncodingForType outputs the encoding for the given type.
func (generator IpldCborTypeEncodingGenerator) WriteEncodingForType(w io.Writer, ti TypeInfo) error {
	log.Infof("Encoding type %s", ti.Name)
	if err := doTemplate(w, ti, `
//
// Encoding/Decoding impls for {{ .Name }} 
// 
	`); err != nil {
		return err
	}

	if !useReflection {
		if err := writeEncode(w, ti); err != nil {
			return err
		}

		if err := writeDecode(w, ti); err != nil {
			return err
		}

		// play nice with ipld-cbor
		// Note: to interface properly with the ipld-cbor library
		// we need to make sure that ipld-cbor recursively calls out encode/decode methods.
		if err := writeAtlasEntry(w, ti); err != nil {
			return err
		}
	}

	return nil
}

func writeEncode(w io.Writer, ti TypeInfo) error {
	return doTemplate(w, ti, `
// Encode was autogenerated.
func (p {{ .Name }}) Encode(encoder encoding.Encoder) error {
	return encoder.EncodeStruct(p)
}
	`)
}

func writeDecode(w io.Writer, ti TypeInfo) error {
	return doTemplate(w, ti, `
// Decode was autogenerated.
func (p *{{ .Name }}) Decode(decoder encoding.Decoder) error {
	return decoder.DecodeStruct(p)
}
`)
}

func writeAtlasEntry(w io.Writer, ti TypeInfo) error {
	// TODO: we need a custom initialize for newtypes (i.e. `type foo uint64`)
	return doTemplate(w, ti, `
var atlasEntry_{{ .Name }} = atlas.BuildEntry({{ .Name }}{}).Transform().
	TransformMarshal(atlas.MakeMarshalTransformFunc(
		func(u {{ .Name }}) ([]byte, error) {
			encoder := encoding.NewIpldCborEncoder()
			if err := u.Encode(&encoder); err != nil {
				return nil, err
			}
			return encoder.Bytes(), nil
		})).
	TransformUnmarshal(atlas.MakeUnmarshalTransformFunc(
		func(x []byte) ({{ .Name }}, error) {
			var aux {{ .Name }}
			decoder := encoding.NewIpldCborDecoder(x)
			if err := (&aux).Decode(&decoder); err != nil {
				return aux, err
			}
			return aux, nil
		})).
	Complete()
`)
}

// Code generated by github.com/filecoin-project/tools/gen/api. DO NOT EDIT.

package v1

import (
	"context"
	"github.com/filecoin-project/go-address"
	"github.com/filecoin-project/go-bitfield"
	"github.com/filecoin-project/go-jsonrpc/auth"
	"github.com/filecoin-project/go-state-types/abi"
	"github.com/filecoin-project/go-state-types/big"
	"github.com/filecoin-project/go-state-types/crypto"
	"github.com/filecoin-project/go-state-types/dline"
	"github.com/filecoin-project/go-state-types/network"
	"github.com/filecoin-project/venus/venus-shared/actors/builtin/miner"
	chain2 "github.com/filecoin-project/venus/venus-shared/api/chain"
	"github.com/filecoin-project/venus/venus-shared/chain"
	"github.com/filecoin-project/venus/venus-shared/libp2p/net"
	"github.com/filecoin-project/venus/venus-shared/messagepool"
	"github.com/filecoin-project/venus/venus-shared/paych"
	"github.com/filecoin-project/venus/venus-shared/wallet"
	"github.com/ipfs/go-cid"
	"github.com/libp2p/go-libp2p-core/metrics"
	"github.com/libp2p/go-libp2p-core/peer"
	ma "github.com/multiformats/go-multiaddr"
	"time"
)

type FullNodeStruct struct {
	IBlockStoreStruct
	IChainStruct
	IMarketStruct
	IMiningStruct
	IMessagePoolStruct
	IMultiSigStruct
	INetworkStruct
	IPaychanStruct
	ISyncerStruct
	IWalletStruct
	IJwtAuthAPIStruct
}

type IAccountStruct struct {
	Internal struct {
		StateAccountKey func(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (address.Address, error) `perm:"read"`
	}
}

func (s *IAccountStruct) StateAccountKey(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (address.Address, error) {
	return s.Internal.StateAccountKey(p0, p1, p2)
}

type IActorStruct struct {
	Internal struct {
		ListActor func(p0 context.Context) (map[address.Address]*chain.Actor, error) `perm:"read"`

		StateGetActor func(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (*chain.Actor, error) `perm:"read"`
	}
}

func (s *IActorStruct) ListActor(p0 context.Context) (map[address.Address]*chain.Actor, error) {
	return s.Internal.ListActor(p0)
}

func (s *IActorStruct) StateGetActor(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (*chain.Actor, error) {
	return s.Internal.StateGetActor(p0, p1, p2)
}

type IBeaconStruct struct {
	Internal struct {
		BeaconGetEntry func(p0 context.Context, p1 abi.ChainEpoch) (*chain.BeaconEntry, error) `perm:"read"`
	}
}

func (s *IBeaconStruct) BeaconGetEntry(p0 context.Context, p1 abi.ChainEpoch) (*chain.BeaconEntry, error) {
	return s.Internal.BeaconGetEntry(p0, p1)
}

type IBlockStoreStruct struct {
	Internal struct {
		ChainDeleteObj func(p0 context.Context, p1 cid.Cid) error `perm:"admin"`

		ChainHasObj func(p0 context.Context, p1 cid.Cid) (bool, error) `perm:"read"`

		ChainReadObj func(p0 context.Context, p1 cid.Cid) ([]byte, error) `perm:"read"`

		ChainStatObj func(p0 context.Context, p1 cid.Cid, p2 cid.Cid) (chain2.ObjStat, error) `perm:"read"`
	}
}

func (s *IBlockStoreStruct) ChainDeleteObj(p0 context.Context, p1 cid.Cid) error {
	return s.Internal.ChainDeleteObj(p0, p1)
}

func (s *IBlockStoreStruct) ChainHasObj(p0 context.Context, p1 cid.Cid) (bool, error) {
	return s.Internal.ChainHasObj(p0, p1)
}

func (s *IBlockStoreStruct) ChainReadObj(p0 context.Context, p1 cid.Cid) ([]byte, error) {
	return s.Internal.ChainReadObj(p0, p1)
}

func (s *IBlockStoreStruct) ChainStatObj(p0 context.Context, p1 cid.Cid, p2 cid.Cid) (chain2.ObjStat, error) {
	return s.Internal.ChainStatObj(p0, p1, p2)
}

type IChainStruct struct {
	IAccountStruct
	IActorStruct
	IBeaconStruct
	IMinerStateStruct
	IChainInfoStruct
}

type IChainInfoStruct struct {
	Internal struct {
		BlockTime func(p0 context.Context) time.Duration `perm:"read"`

		ChainExport func(p0 context.Context, p1 abi.ChainEpoch, p2 bool, p3 chain.TipSetKey) (<-chan []byte, error) `perm:"read"`

		ChainGetBlock func(p0 context.Context, p1 cid.Cid) (*chain.BlockHeader, error) `perm:"read"`

		ChainGetBlockMessages func(p0 context.Context, p1 cid.Cid) (*chain2.BlockMessages, error) `perm:"read"`

		ChainGetMessage func(p0 context.Context, p1 cid.Cid) (*chain.Message, error) `perm:"read"`

		ChainGetMessagesInTipset func(p0 context.Context, p1 chain.TipSetKey) ([]chain2.Message, error) `perm:"read"`

		ChainGetParentMessages func(p0 context.Context, p1 cid.Cid) ([]chain2.Message, error) `perm:"read"`

		ChainGetParentReceipts func(p0 context.Context, p1 cid.Cid) ([]*chain.MessageReceipt, error) `perm:"read"`

		ChainGetPath func(p0 context.Context, p1 chain.TipSetKey, p2 chain.TipSetKey) ([]*chain2.HeadChange, error) `perm:"read"`

		ChainGetRandomnessFromBeacon func(p0 context.Context, p1 chain.TipSetKey, p2 crypto.DomainSeparationTag, p3 abi.ChainEpoch, p4 []byte) (abi.Randomness, error) `perm:"read"`

		ChainGetRandomnessFromTickets func(p0 context.Context, p1 chain.TipSetKey, p2 crypto.DomainSeparationTag, p3 abi.ChainEpoch, p4 []byte) (abi.Randomness, error) `perm:"read"`

		ChainGetReceipts func(p0 context.Context, p1 cid.Cid) ([]chain.MessageReceipt, error) `perm:"read"`

		ChainGetTipSet func(p0 context.Context, p1 chain.TipSetKey) (*chain.TipSet, error) `perm:"read"`

		ChainGetTipSetAfterHeight func(p0 context.Context, p1 abi.ChainEpoch, p2 chain.TipSetKey) (*chain.TipSet, error) `perm:"read"`

		ChainGetTipSetByHeight func(p0 context.Context, p1 abi.ChainEpoch, p2 chain.TipSetKey) (*chain.TipSet, error) `perm:"read"`

		ChainHead func(p0 context.Context) (*chain.TipSet, error) `perm:"read"`

		ChainList func(p0 context.Context, p1 chain.TipSetKey, p2 int) ([]chain.TipSetKey, error) `perm:"read"`

		ChainNotify func(p0 context.Context) (<-chan []*chain2.HeadChange, error) `perm:"read"`

		ChainSetHead func(p0 context.Context, p1 chain.TipSetKey) error `perm:"admin"`

		GetActor func(p0 context.Context, p1 address.Address) (*chain.Actor, error) `perm:"read"`

		GetEntry func(p0 context.Context, p1 abi.ChainEpoch, p2 uint64) (*chain.BeaconEntry, error) `perm:"read"`

		GetFullBlock func(p0 context.Context, p1 cid.Cid) (*chain.FullBlock, error) `perm:"read"`

		GetParentStateRootActor func(p0 context.Context, p1 *chain.TipSet, p2 address.Address) (*chain.Actor, error) `perm:"read"`

		MessageWait func(p0 context.Context, p1 cid.Cid, p2 abi.ChainEpoch, p3 abi.ChainEpoch) (*chain2.ChainMessage, error) `perm:"read"`

		ProtocolParameters func(p0 context.Context) (*chain2.ProtocolParams, error) `perm:"read"`

		ResolveToKeyAddr func(p0 context.Context, p1 address.Address, p2 *chain.TipSet) (address.Address, error) `perm:"read"`

		StateGetRandomnessFromBeacon func(p0 context.Context, p1 crypto.DomainSeparationTag, p2 abi.ChainEpoch, p3 []byte, p4 chain.TipSetKey) (abi.Randomness, error) `perm:"read"`

		StateGetRandomnessFromTickets func(p0 context.Context, p1 crypto.DomainSeparationTag, p2 abi.ChainEpoch, p3 []byte, p4 chain.TipSetKey) (abi.Randomness, error) `perm:"read"`

		StateNetworkName func(p0 context.Context) (chain2.NetworkName, error) `perm:"read"`

		StateNetworkVersion func(p0 context.Context, p1 chain.TipSetKey) (network.Version, error) `perm:"read"`

		StateSearchMsg func(p0 context.Context, p1 chain.TipSetKey, p2 cid.Cid, p3 abi.ChainEpoch, p4 bool) (*chain2.MsgLookup, error) `perm:"read"`

		StateVerifiedRegistryRootKey func(p0 context.Context, p1 chain.TipSetKey) (address.Address, error) `perm:"read"`

		StateVerifierStatus func(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (*abi.StoragePower, error) `perm:"read"`

		StateWaitMsg func(p0 context.Context, p1 cid.Cid, p2 uint64, p3 abi.ChainEpoch, p4 bool) (*chain2.MsgLookup, error) `perm:"read"`

		VerifyEntry func(p0 *chain.BeaconEntry, p1 *chain.BeaconEntry, p2 abi.ChainEpoch) bool `perm:"read"`
	}
}

func (s *IChainInfoStruct) BlockTime(p0 context.Context) time.Duration {
	return s.Internal.BlockTime(p0)
}

func (s *IChainInfoStruct) ChainExport(p0 context.Context, p1 abi.ChainEpoch, p2 bool, p3 chain.TipSetKey) (<-chan []byte, error) {
	return s.Internal.ChainExport(p0, p1, p2, p3)
}

func (s *IChainInfoStruct) ChainGetBlock(p0 context.Context, p1 cid.Cid) (*chain.BlockHeader, error) {
	return s.Internal.ChainGetBlock(p0, p1)
}

func (s *IChainInfoStruct) ChainGetBlockMessages(p0 context.Context, p1 cid.Cid) (*chain2.BlockMessages, error) {
	return s.Internal.ChainGetBlockMessages(p0, p1)
}

func (s *IChainInfoStruct) ChainGetMessage(p0 context.Context, p1 cid.Cid) (*chain.Message, error) {
	return s.Internal.ChainGetMessage(p0, p1)
}

func (s *IChainInfoStruct) ChainGetMessagesInTipset(p0 context.Context, p1 chain.TipSetKey) ([]chain2.Message, error) {
	return s.Internal.ChainGetMessagesInTipset(p0, p1)
}

func (s *IChainInfoStruct) ChainGetParentMessages(p0 context.Context, p1 cid.Cid) ([]chain2.Message, error) {
	return s.Internal.ChainGetParentMessages(p0, p1)
}

func (s *IChainInfoStruct) ChainGetParentReceipts(p0 context.Context, p1 cid.Cid) ([]*chain.MessageReceipt, error) {
	return s.Internal.ChainGetParentReceipts(p0, p1)
}

func (s *IChainInfoStruct) ChainGetPath(p0 context.Context, p1 chain.TipSetKey, p2 chain.TipSetKey) ([]*chain2.HeadChange, error) {
	return s.Internal.ChainGetPath(p0, p1, p2)
}

func (s *IChainInfoStruct) ChainGetRandomnessFromBeacon(p0 context.Context, p1 chain.TipSetKey, p2 crypto.DomainSeparationTag, p3 abi.ChainEpoch, p4 []byte) (abi.Randomness, error) {
	return s.Internal.ChainGetRandomnessFromBeacon(p0, p1, p2, p3, p4)
}

func (s *IChainInfoStruct) ChainGetRandomnessFromTickets(p0 context.Context, p1 chain.TipSetKey, p2 crypto.DomainSeparationTag, p3 abi.ChainEpoch, p4 []byte) (abi.Randomness, error) {
	return s.Internal.ChainGetRandomnessFromTickets(p0, p1, p2, p3, p4)
}

func (s *IChainInfoStruct) ChainGetReceipts(p0 context.Context, p1 cid.Cid) ([]chain.MessageReceipt, error) {
	return s.Internal.ChainGetReceipts(p0, p1)
}

func (s *IChainInfoStruct) ChainGetTipSet(p0 context.Context, p1 chain.TipSetKey) (*chain.TipSet, error) {
	return s.Internal.ChainGetTipSet(p0, p1)
}

func (s *IChainInfoStruct) ChainGetTipSetAfterHeight(p0 context.Context, p1 abi.ChainEpoch, p2 chain.TipSetKey) (*chain.TipSet, error) {
	return s.Internal.ChainGetTipSetAfterHeight(p0, p1, p2)
}

func (s *IChainInfoStruct) ChainGetTipSetByHeight(p0 context.Context, p1 abi.ChainEpoch, p2 chain.TipSetKey) (*chain.TipSet, error) {
	return s.Internal.ChainGetTipSetByHeight(p0, p1, p2)
}

func (s *IChainInfoStruct) ChainHead(p0 context.Context) (*chain.TipSet, error) {
	return s.Internal.ChainHead(p0)
}

func (s *IChainInfoStruct) ChainList(p0 context.Context, p1 chain.TipSetKey, p2 int) ([]chain.TipSetKey, error) {
	return s.Internal.ChainList(p0, p1, p2)
}

func (s *IChainInfoStruct) ChainNotify(p0 context.Context) (<-chan []*chain2.HeadChange, error) {
	return s.Internal.ChainNotify(p0)
}

func (s *IChainInfoStruct) ChainSetHead(p0 context.Context, p1 chain.TipSetKey) error {
	return s.Internal.ChainSetHead(p0, p1)
}

func (s *IChainInfoStruct) GetActor(p0 context.Context, p1 address.Address) (*chain.Actor, error) {
	return s.Internal.GetActor(p0, p1)
}

func (s *IChainInfoStruct) GetEntry(p0 context.Context, p1 abi.ChainEpoch, p2 uint64) (*chain.BeaconEntry, error) {
	return s.Internal.GetEntry(p0, p1, p2)
}

func (s *IChainInfoStruct) GetFullBlock(p0 context.Context, p1 cid.Cid) (*chain.FullBlock, error) {
	return s.Internal.GetFullBlock(p0, p1)
}

func (s *IChainInfoStruct) GetParentStateRootActor(p0 context.Context, p1 *chain.TipSet, p2 address.Address) (*chain.Actor, error) {
	return s.Internal.GetParentStateRootActor(p0, p1, p2)
}

func (s *IChainInfoStruct) MessageWait(p0 context.Context, p1 cid.Cid, p2 abi.ChainEpoch, p3 abi.ChainEpoch) (*chain2.ChainMessage, error) {
	return s.Internal.MessageWait(p0, p1, p2, p3)
}

func (s *IChainInfoStruct) ProtocolParameters(p0 context.Context) (*chain2.ProtocolParams, error) {
	return s.Internal.ProtocolParameters(p0)
}

func (s *IChainInfoStruct) ResolveToKeyAddr(p0 context.Context, p1 address.Address, p2 *chain.TipSet) (address.Address, error) {
	return s.Internal.ResolveToKeyAddr(p0, p1, p2)
}

func (s *IChainInfoStruct) StateGetRandomnessFromBeacon(p0 context.Context, p1 crypto.DomainSeparationTag, p2 abi.ChainEpoch, p3 []byte, p4 chain.TipSetKey) (abi.Randomness, error) {
	return s.Internal.StateGetRandomnessFromBeacon(p0, p1, p2, p3, p4)
}

func (s *IChainInfoStruct) StateGetRandomnessFromTickets(p0 context.Context, p1 crypto.DomainSeparationTag, p2 abi.ChainEpoch, p3 []byte, p4 chain.TipSetKey) (abi.Randomness, error) {
	return s.Internal.StateGetRandomnessFromTickets(p0, p1, p2, p3, p4)
}

func (s *IChainInfoStruct) StateNetworkName(p0 context.Context) (chain2.NetworkName, error) {
	return s.Internal.StateNetworkName(p0)
}

func (s *IChainInfoStruct) StateNetworkVersion(p0 context.Context, p1 chain.TipSetKey) (network.Version, error) {
	return s.Internal.StateNetworkVersion(p0, p1)
}

func (s *IChainInfoStruct) StateSearchMsg(p0 context.Context, p1 chain.TipSetKey, p2 cid.Cid, p3 abi.ChainEpoch, p4 bool) (*chain2.MsgLookup, error) {
	return s.Internal.StateSearchMsg(p0, p1, p2, p3, p4)
}

func (s *IChainInfoStruct) StateVerifiedRegistryRootKey(p0 context.Context, p1 chain.TipSetKey) (address.Address, error) {
	return s.Internal.StateVerifiedRegistryRootKey(p0, p1)
}

func (s *IChainInfoStruct) StateVerifierStatus(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (*abi.StoragePower, error) {
	return s.Internal.StateVerifierStatus(p0, p1, p2)
}

func (s *IChainInfoStruct) StateWaitMsg(p0 context.Context, p1 cid.Cid, p2 uint64, p3 abi.ChainEpoch, p4 bool) (*chain2.MsgLookup, error) {
	return s.Internal.StateWaitMsg(p0, p1, p2, p3, p4)
}

func (s *IChainInfoStruct) VerifyEntry(p0 *chain.BeaconEntry, p1 *chain.BeaconEntry, p2 abi.ChainEpoch) bool {
	return s.Internal.VerifyEntry(p0, p1, p2)
}

type IJwtAuthAPIStruct struct {
	Internal struct {
		AuthNew func(p0 context.Context, p1 []auth.Permission) ([]byte, error) `perm:"admin"`

		Verify func(p0 context.Context, p1 string, p2 string) ([]auth.Permission, error) `perm:"read"`
	}
}

func (s *IJwtAuthAPIStruct) AuthNew(p0 context.Context, p1 []auth.Permission) ([]byte, error) {
	return s.Internal.AuthNew(p0, p1)
}

func (s *IJwtAuthAPIStruct) Verify(p0 context.Context, p1 string, p2 string) ([]auth.Permission, error) {
	return s.Internal.Verify(p0, p1, p2)
}

type IMarketStruct struct {
	Internal struct {
		StateMarketParticipants func(p0 context.Context, p1 chain.TipSetKey) (map[string]chain2.MarketBalance, error) `perm:"read"`
	}
}

func (s *IMarketStruct) StateMarketParticipants(p0 context.Context, p1 chain.TipSetKey) (map[string]chain2.MarketBalance, error) {
	return s.Internal.StateMarketParticipants(p0, p1)
}

type IMessagePoolStruct struct {
	Internal struct {
		GasBatchEstimateMessageGas func(p0 context.Context, p1 []*chain2.EstimateMessage, p2 uint64, p3 chain.TipSetKey) ([]*chain2.EstimateResult, error) `perm:"read"`

		GasEstimateFeeCap func(p0 context.Context, p1 *chain.Message, p2 int64, p3 chain.TipSetKey) (big.Int, error) `perm:"read"`

		GasEstimateGasLimit func(p0 context.Context, p1 *chain.Message, p2 chain.TipSetKey) (int64, error) `perm:"read"`

		GasEstimateGasPremium func(p0 context.Context, p1 uint64, p2 address.Address, p3 int64, p4 chain.TipSetKey) (big.Int, error) `perm:"read"`

		GasEstimateMessageGas func(p0 context.Context, p1 *chain.Message, p2 *chain2.MessageSendSpec, p3 chain.TipSetKey) (*chain.Message, error) `perm:"read"`

		MpoolBatchPush func(p0 context.Context, p1 []*chain.SignedMessage) ([]cid.Cid, error) `perm:"write"`

		MpoolBatchPushMessage func(p0 context.Context, p1 []*chain.Message, p2 *chain2.MessageSendSpec) ([]*chain.SignedMessage, error) `perm:"sign"`

		MpoolBatchPushUntrusted func(p0 context.Context, p1 []*chain.SignedMessage) ([]cid.Cid, error) `perm:"write"`

		MpoolCheckMessages func(p0 context.Context, p1 []*messagepool.MessagePrototype) ([][]messagepool.MessageCheckStatus, error) `perm:"read"`

		MpoolCheckPendingMessages func(p0 context.Context, p1 address.Address) ([][]messagepool.MessageCheckStatus, error) `perm:"read"`

		MpoolCheckReplaceMessages func(p0 context.Context, p1 []*chain.Message) ([][]messagepool.MessageCheckStatus, error) `perm:"read"`

		MpoolClear func(p0 context.Context, p1 bool) error `perm:"write"`

		MpoolDeleteByAdress func(p0 context.Context, p1 address.Address) error `perm:"admin"`

		MpoolGetConfig func(p0 context.Context) (*messagepool.MpoolConfig, error) `perm:"read"`

		MpoolGetNonce func(p0 context.Context, p1 address.Address) (uint64, error) `perm:"read"`

		MpoolPending func(p0 context.Context, p1 chain.TipSetKey) ([]*chain.SignedMessage, error) `perm:"read"`

		MpoolPublishByAddr func(p0 context.Context, p1 address.Address) error `perm:"write"`

		MpoolPublishMessage func(p0 context.Context, p1 *chain.SignedMessage) error `perm:"write"`

		MpoolPush func(p0 context.Context, p1 *chain.SignedMessage) (cid.Cid, error) `perm:"write"`

		MpoolPushMessage func(p0 context.Context, p1 *chain.Message, p2 *chain2.MessageSendSpec) (*chain.SignedMessage, error) `perm:"sign"`

		MpoolPushUntrusted func(p0 context.Context, p1 *chain.SignedMessage) (cid.Cid, error) `perm:"write"`

		MpoolSelect func(p0 context.Context, p1 chain.TipSetKey, p2 float64) ([]*chain.SignedMessage, error) `perm:"read"`

		MpoolSelects func(p0 context.Context, p1 chain.TipSetKey, p2 []float64) ([][]*chain.SignedMessage, error) `perm:"read"`

		MpoolSetConfig func(p0 context.Context, p1 *messagepool.MpoolConfig) error `perm:"admin"`

		MpoolSub func(p0 context.Context) (<-chan messagepool.MpoolUpdate, error) `perm:"read"`
	}
}

func (s *IMessagePoolStruct) GasBatchEstimateMessageGas(p0 context.Context, p1 []*chain2.EstimateMessage, p2 uint64, p3 chain.TipSetKey) ([]*chain2.EstimateResult, error) {
	return s.Internal.GasBatchEstimateMessageGas(p0, p1, p2, p3)
}

func (s *IMessagePoolStruct) GasEstimateFeeCap(p0 context.Context, p1 *chain.Message, p2 int64, p3 chain.TipSetKey) (big.Int, error) {
	return s.Internal.GasEstimateFeeCap(p0, p1, p2, p3)
}

func (s *IMessagePoolStruct) GasEstimateGasLimit(p0 context.Context, p1 *chain.Message, p2 chain.TipSetKey) (int64, error) {
	return s.Internal.GasEstimateGasLimit(p0, p1, p2)
}

func (s *IMessagePoolStruct) GasEstimateGasPremium(p0 context.Context, p1 uint64, p2 address.Address, p3 int64, p4 chain.TipSetKey) (big.Int, error) {
	return s.Internal.GasEstimateGasPremium(p0, p1, p2, p3, p4)
}

func (s *IMessagePoolStruct) GasEstimateMessageGas(p0 context.Context, p1 *chain.Message, p2 *chain2.MessageSendSpec, p3 chain.TipSetKey) (*chain.Message, error) {
	return s.Internal.GasEstimateMessageGas(p0, p1, p2, p3)
}

func (s *IMessagePoolStruct) MpoolBatchPush(p0 context.Context, p1 []*chain.SignedMessage) ([]cid.Cid, error) {
	return s.Internal.MpoolBatchPush(p0, p1)
}

func (s *IMessagePoolStruct) MpoolBatchPushMessage(p0 context.Context, p1 []*chain.Message, p2 *chain2.MessageSendSpec) ([]*chain.SignedMessage, error) {
	return s.Internal.MpoolBatchPushMessage(p0, p1, p2)
}

func (s *IMessagePoolStruct) MpoolBatchPushUntrusted(p0 context.Context, p1 []*chain.SignedMessage) ([]cid.Cid, error) {
	return s.Internal.MpoolBatchPushUntrusted(p0, p1)
}

func (s *IMessagePoolStruct) MpoolCheckMessages(p0 context.Context, p1 []*messagepool.MessagePrototype) ([][]messagepool.MessageCheckStatus, error) {
	return s.Internal.MpoolCheckMessages(p0, p1)
}

func (s *IMessagePoolStruct) MpoolCheckPendingMessages(p0 context.Context, p1 address.Address) ([][]messagepool.MessageCheckStatus, error) {
	return s.Internal.MpoolCheckPendingMessages(p0, p1)
}

func (s *IMessagePoolStruct) MpoolCheckReplaceMessages(p0 context.Context, p1 []*chain.Message) ([][]messagepool.MessageCheckStatus, error) {
	return s.Internal.MpoolCheckReplaceMessages(p0, p1)
}

func (s *IMessagePoolStruct) MpoolClear(p0 context.Context, p1 bool) error {
	return s.Internal.MpoolClear(p0, p1)
}

func (s *IMessagePoolStruct) MpoolDeleteByAdress(p0 context.Context, p1 address.Address) error {
	return s.Internal.MpoolDeleteByAdress(p0, p1)
}

func (s *IMessagePoolStruct) MpoolGetConfig(p0 context.Context) (*messagepool.MpoolConfig, error) {
	return s.Internal.MpoolGetConfig(p0)
}

func (s *IMessagePoolStruct) MpoolGetNonce(p0 context.Context, p1 address.Address) (uint64, error) {
	return s.Internal.MpoolGetNonce(p0, p1)
}

func (s *IMessagePoolStruct) MpoolPending(p0 context.Context, p1 chain.TipSetKey) ([]*chain.SignedMessage, error) {
	return s.Internal.MpoolPending(p0, p1)
}

func (s *IMessagePoolStruct) MpoolPublishByAddr(p0 context.Context, p1 address.Address) error {
	return s.Internal.MpoolPublishByAddr(p0, p1)
}

func (s *IMessagePoolStruct) MpoolPublishMessage(p0 context.Context, p1 *chain.SignedMessage) error {
	return s.Internal.MpoolPublishMessage(p0, p1)
}

func (s *IMessagePoolStruct) MpoolPush(p0 context.Context, p1 *chain.SignedMessage) (cid.Cid, error) {
	return s.Internal.MpoolPush(p0, p1)
}

func (s *IMessagePoolStruct) MpoolPushMessage(p0 context.Context, p1 *chain.Message, p2 *chain2.MessageSendSpec) (*chain.SignedMessage, error) {
	return s.Internal.MpoolPushMessage(p0, p1, p2)
}

func (s *IMessagePoolStruct) MpoolPushUntrusted(p0 context.Context, p1 *chain.SignedMessage) (cid.Cid, error) {
	return s.Internal.MpoolPushUntrusted(p0, p1)
}

func (s *IMessagePoolStruct) MpoolSelect(p0 context.Context, p1 chain.TipSetKey, p2 float64) ([]*chain.SignedMessage, error) {
	return s.Internal.MpoolSelect(p0, p1, p2)
}

func (s *IMessagePoolStruct) MpoolSelects(p0 context.Context, p1 chain.TipSetKey, p2 []float64) ([][]*chain.SignedMessage, error) {
	return s.Internal.MpoolSelects(p0, p1, p2)
}

func (s *IMessagePoolStruct) MpoolSetConfig(p0 context.Context, p1 *messagepool.MpoolConfig) error {
	return s.Internal.MpoolSetConfig(p0, p1)
}

func (s *IMessagePoolStruct) MpoolSub(p0 context.Context) (<-chan messagepool.MpoolUpdate, error) {
	return s.Internal.MpoolSub(p0)
}

type IMinerStateStruct struct {
	Internal struct {
		StateCirculatingSupply func(p0 context.Context, p1 chain.TipSetKey) (abi.TokenAmount, error) `perm:"read"`

		StateDealProviderCollateralBounds func(p0 context.Context, p1 abi.PaddedPieceSize, p2 bool, p3 chain.TipSetKey) (chain2.DealCollateralBounds, error) `perm:"read"`

		StateListActors func(p0 context.Context, p1 chain.TipSetKey) ([]address.Address, error) `perm:"read"`

		StateListMiners func(p0 context.Context, p1 chain.TipSetKey) ([]address.Address, error) `perm:"read"`

		StateLookupID func(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (address.Address, error) `perm:"read"`

		StateMarketBalance func(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (chain2.MarketBalance, error) `perm:"read"`

		StateMarketDeals func(p0 context.Context, p1 chain.TipSetKey) (map[string]chain2.MarketDeal, error) `perm:"read"`

		StateMarketStorageDeal func(p0 context.Context, p1 abi.DealID, p2 chain.TipSetKey) (*chain2.MarketDeal, error) `perm:"read"`

		StateMinerActiveSectors func(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) ([]*miner.SectorOnChainInfo, error) `perm:"read"`

		StateMinerAvailableBalance func(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (big.Int, error) `perm:"read"`

		StateMinerDeadlines func(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) ([]chain2.Deadline, error) `perm:"read"`

		StateMinerFaults func(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (bitfield.BitField, error) `perm:"read"`

		StateMinerInfo func(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (miner.MinerInfo, error) `perm:"read"`

		StateMinerInitialPledgeCollateral func(p0 context.Context, p1 address.Address, p2 miner.SectorPreCommitInfo, p3 chain.TipSetKey) (big.Int, error) `perm:"read"`

		StateMinerPartitions func(p0 context.Context, p1 address.Address, p2 uint64, p3 chain.TipSetKey) ([]chain2.Partition, error) `perm:"read"`

		StateMinerPower func(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (*chain2.MinerPower, error) `perm:"read"`

		StateMinerPreCommitDepositForPower func(p0 context.Context, p1 address.Address, p2 miner.SectorPreCommitInfo, p3 chain.TipSetKey) (big.Int, error) `perm:"read"`

		StateMinerProvingDeadline func(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (*dline.Info, error) `perm:"read"`

		StateMinerRecoveries func(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (bitfield.BitField, error) `perm:"read"`

		StateMinerSectorAllocated func(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 chain.TipSetKey) (bool, error) `perm:"read"`

		StateMinerSectorCount func(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (chain2.MinerSectors, error) `perm:"read"`

		StateMinerSectorSize func(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (abi.SectorSize, error) `perm:"read"`

		StateMinerSectors func(p0 context.Context, p1 address.Address, p2 *bitfield.BitField, p3 chain.TipSetKey) ([]*miner.SectorOnChainInfo, error) `perm:"read"`

		StateMinerWorkerAddress func(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (address.Address, error) `perm:"read"`

		StateSectorExpiration func(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 chain.TipSetKey) (*miner.SectorExpiration, error) `perm:"read"`

		StateSectorGetInfo func(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 chain.TipSetKey) (*miner.SectorOnChainInfo, error) `perm:"read"`

		StateSectorPartition func(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 chain.TipSetKey) (*miner.SectorLocation, error) `perm:"read"`

		StateSectorPreCommitInfo func(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 chain.TipSetKey) (miner.SectorPreCommitOnChainInfo, error) `perm:"read"`

		StateVMCirculatingSupplyInternal func(p0 context.Context, p1 chain.TipSetKey) (chain.CirculatingSupply, error) `perm:"read"`

		StateVerifiedClientStatus func(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (*abi.StoragePower, error) `perm:"read"`
	}
}

func (s *IMinerStateStruct) StateCirculatingSupply(p0 context.Context, p1 chain.TipSetKey) (abi.TokenAmount, error) {
	return s.Internal.StateCirculatingSupply(p0, p1)
}

func (s *IMinerStateStruct) StateDealProviderCollateralBounds(p0 context.Context, p1 abi.PaddedPieceSize, p2 bool, p3 chain.TipSetKey) (chain2.DealCollateralBounds, error) {
	return s.Internal.StateDealProviderCollateralBounds(p0, p1, p2, p3)
}

func (s *IMinerStateStruct) StateListActors(p0 context.Context, p1 chain.TipSetKey) ([]address.Address, error) {
	return s.Internal.StateListActors(p0, p1)
}

func (s *IMinerStateStruct) StateListMiners(p0 context.Context, p1 chain.TipSetKey) ([]address.Address, error) {
	return s.Internal.StateListMiners(p0, p1)
}

func (s *IMinerStateStruct) StateLookupID(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (address.Address, error) {
	return s.Internal.StateLookupID(p0, p1, p2)
}

func (s *IMinerStateStruct) StateMarketBalance(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (chain2.MarketBalance, error) {
	return s.Internal.StateMarketBalance(p0, p1, p2)
}

func (s *IMinerStateStruct) StateMarketDeals(p0 context.Context, p1 chain.TipSetKey) (map[string]chain2.MarketDeal, error) {
	return s.Internal.StateMarketDeals(p0, p1)
}

func (s *IMinerStateStruct) StateMarketStorageDeal(p0 context.Context, p1 abi.DealID, p2 chain.TipSetKey) (*chain2.MarketDeal, error) {
	return s.Internal.StateMarketStorageDeal(p0, p1, p2)
}

func (s *IMinerStateStruct) StateMinerActiveSectors(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) ([]*miner.SectorOnChainInfo, error) {
	return s.Internal.StateMinerActiveSectors(p0, p1, p2)
}

func (s *IMinerStateStruct) StateMinerAvailableBalance(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (big.Int, error) {
	return s.Internal.StateMinerAvailableBalance(p0, p1, p2)
}

func (s *IMinerStateStruct) StateMinerDeadlines(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) ([]chain2.Deadline, error) {
	return s.Internal.StateMinerDeadlines(p0, p1, p2)
}

func (s *IMinerStateStruct) StateMinerFaults(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (bitfield.BitField, error) {
	return s.Internal.StateMinerFaults(p0, p1, p2)
}

func (s *IMinerStateStruct) StateMinerInfo(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (miner.MinerInfo, error) {
	return s.Internal.StateMinerInfo(p0, p1, p2)
}

func (s *IMinerStateStruct) StateMinerInitialPledgeCollateral(p0 context.Context, p1 address.Address, p2 miner.SectorPreCommitInfo, p3 chain.TipSetKey) (big.Int, error) {
	return s.Internal.StateMinerInitialPledgeCollateral(p0, p1, p2, p3)
}

func (s *IMinerStateStruct) StateMinerPartitions(p0 context.Context, p1 address.Address, p2 uint64, p3 chain.TipSetKey) ([]chain2.Partition, error) {
	return s.Internal.StateMinerPartitions(p0, p1, p2, p3)
}

func (s *IMinerStateStruct) StateMinerPower(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (*chain2.MinerPower, error) {
	return s.Internal.StateMinerPower(p0, p1, p2)
}

func (s *IMinerStateStruct) StateMinerPreCommitDepositForPower(p0 context.Context, p1 address.Address, p2 miner.SectorPreCommitInfo, p3 chain.TipSetKey) (big.Int, error) {
	return s.Internal.StateMinerPreCommitDepositForPower(p0, p1, p2, p3)
}

func (s *IMinerStateStruct) StateMinerProvingDeadline(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (*dline.Info, error) {
	return s.Internal.StateMinerProvingDeadline(p0, p1, p2)
}

func (s *IMinerStateStruct) StateMinerRecoveries(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (bitfield.BitField, error) {
	return s.Internal.StateMinerRecoveries(p0, p1, p2)
}

func (s *IMinerStateStruct) StateMinerSectorAllocated(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 chain.TipSetKey) (bool, error) {
	return s.Internal.StateMinerSectorAllocated(p0, p1, p2, p3)
}

func (s *IMinerStateStruct) StateMinerSectorCount(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (chain2.MinerSectors, error) {
	return s.Internal.StateMinerSectorCount(p0, p1, p2)
}

func (s *IMinerStateStruct) StateMinerSectorSize(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (abi.SectorSize, error) {
	return s.Internal.StateMinerSectorSize(p0, p1, p2)
}

func (s *IMinerStateStruct) StateMinerSectors(p0 context.Context, p1 address.Address, p2 *bitfield.BitField, p3 chain.TipSetKey) ([]*miner.SectorOnChainInfo, error) {
	return s.Internal.StateMinerSectors(p0, p1, p2, p3)
}

func (s *IMinerStateStruct) StateMinerWorkerAddress(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (address.Address, error) {
	return s.Internal.StateMinerWorkerAddress(p0, p1, p2)
}

func (s *IMinerStateStruct) StateSectorExpiration(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 chain.TipSetKey) (*miner.SectorExpiration, error) {
	return s.Internal.StateSectorExpiration(p0, p1, p2, p3)
}

func (s *IMinerStateStruct) StateSectorGetInfo(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 chain.TipSetKey) (*miner.SectorOnChainInfo, error) {
	return s.Internal.StateSectorGetInfo(p0, p1, p2, p3)
}

func (s *IMinerStateStruct) StateSectorPartition(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 chain.TipSetKey) (*miner.SectorLocation, error) {
	return s.Internal.StateSectorPartition(p0, p1, p2, p3)
}

func (s *IMinerStateStruct) StateSectorPreCommitInfo(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 chain.TipSetKey) (miner.SectorPreCommitOnChainInfo, error) {
	return s.Internal.StateSectorPreCommitInfo(p0, p1, p2, p3)
}

func (s *IMinerStateStruct) StateVMCirculatingSupplyInternal(p0 context.Context, p1 chain.TipSetKey) (chain.CirculatingSupply, error) {
	return s.Internal.StateVMCirculatingSupplyInternal(p0, p1)
}

func (s *IMinerStateStruct) StateVerifiedClientStatus(p0 context.Context, p1 address.Address, p2 chain.TipSetKey) (*abi.StoragePower, error) {
	return s.Internal.StateVerifiedClientStatus(p0, p1, p2)
}

type IMiningStruct struct {
	Internal struct {
		MinerCreateBlock func(p0 context.Context, p1 *chain2.BlockTemplate) (*chain.BlockMsg, error) `perm:"write"`

		MinerGetBaseInfo func(p0 context.Context, p1 address.Address, p2 abi.ChainEpoch, p3 chain.TipSetKey) (*chain2.MiningBaseInfo, error) `perm:"read"`
	}
}

func (s *IMiningStruct) MinerCreateBlock(p0 context.Context, p1 *chain2.BlockTemplate) (*chain.BlockMsg, error) {
	return s.Internal.MinerCreateBlock(p0, p1)
}

func (s *IMiningStruct) MinerGetBaseInfo(p0 context.Context, p1 address.Address, p2 abi.ChainEpoch, p3 chain.TipSetKey) (*chain2.MiningBaseInfo, error) {
	return s.Internal.MinerGetBaseInfo(p0, p1, p2, p3)
}

type IMultiSigStruct struct {
	Internal struct {
		MsigAddApprove func(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 address.Address, p6 bool) (*messagepool.MessagePrototype, error) `perm:"sign"`

		MsigAddCancel func(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 bool) (*messagepool.MessagePrototype, error) `perm:"sign"`

		MsigAddPropose func(p0 context.Context, p1 address.Address, p2 address.Address, p3 address.Address, p4 bool) (*messagepool.MessagePrototype, error) `perm:"sign"`

		MsigApprove func(p0 context.Context, p1 address.Address, p2 uint64, p3 address.Address) (*messagepool.MessagePrototype, error) `perm:"sign"`

		MsigApproveTxnHash func(p0 context.Context, p1 address.Address, p2 uint64, p3 address.Address, p4 address.Address, p5 chain.BigInt, p6 address.Address, p7 uint64, p8 []byte) (*messagepool.MessagePrototype, error) `perm:"sign"`

		MsigCancel func(p0 context.Context, p1 address.Address, p2 uint64, p3 address.Address, p4 chain.BigInt, p5 address.Address, p6 uint64, p7 []byte) (*messagepool.MessagePrototype, error) `perm:"sign"`

		MsigCreate func(p0 context.Context, p1 uint64, p2 []address.Address, p3 abi.ChainEpoch, p4 chain.BigInt, p5 address.Address, p6 chain.BigInt) (*messagepool.MessagePrototype, error) `perm:"sign"`

		MsigGetVested func(p0 context.Context, p1 address.Address, p2 chain.TipSetKey, p3 chain.TipSetKey) (chain.BigInt, error) `perm:"read"`

		MsigPropose func(p0 context.Context, p1 address.Address, p2 address.Address, p3 chain.BigInt, p4 address.Address, p5 uint64, p6 []byte) (*messagepool.MessagePrototype, error) `perm:"sign"`

		MsigRemoveSigner func(p0 context.Context, p1 address.Address, p2 address.Address, p3 address.Address, p4 bool) (*messagepool.MessagePrototype, error) `perm:"sign"`

		MsigSwapApprove func(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 address.Address, p6 address.Address) (*messagepool.MessagePrototype, error) `perm:"sign"`

		MsigSwapCancel func(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 address.Address) (*messagepool.MessagePrototype, error) `perm:"sign"`

		MsigSwapPropose func(p0 context.Context, p1 address.Address, p2 address.Address, p3 address.Address, p4 address.Address) (*messagepool.MessagePrototype, error) `perm:"sign"`
	}
}

func (s *IMultiSigStruct) MsigAddApprove(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 address.Address, p6 bool) (*messagepool.MessagePrototype, error) {
	return s.Internal.MsigAddApprove(p0, p1, p2, p3, p4, p5, p6)
}

func (s *IMultiSigStruct) MsigAddCancel(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 bool) (*messagepool.MessagePrototype, error) {
	return s.Internal.MsigAddCancel(p0, p1, p2, p3, p4, p5)
}

func (s *IMultiSigStruct) MsigAddPropose(p0 context.Context, p1 address.Address, p2 address.Address, p3 address.Address, p4 bool) (*messagepool.MessagePrototype, error) {
	return s.Internal.MsigAddPropose(p0, p1, p2, p3, p4)
}

func (s *IMultiSigStruct) MsigApprove(p0 context.Context, p1 address.Address, p2 uint64, p3 address.Address) (*messagepool.MessagePrototype, error) {
	return s.Internal.MsigApprove(p0, p1, p2, p3)
}

func (s *IMultiSigStruct) MsigApproveTxnHash(p0 context.Context, p1 address.Address, p2 uint64, p3 address.Address, p4 address.Address, p5 chain.BigInt, p6 address.Address, p7 uint64, p8 []byte) (*messagepool.MessagePrototype, error) {
	return s.Internal.MsigApproveTxnHash(p0, p1, p2, p3, p4, p5, p6, p7, p8)
}

func (s *IMultiSigStruct) MsigCancel(p0 context.Context, p1 address.Address, p2 uint64, p3 address.Address, p4 chain.BigInt, p5 address.Address, p6 uint64, p7 []byte) (*messagepool.MessagePrototype, error) {
	return s.Internal.MsigCancel(p0, p1, p2, p3, p4, p5, p6, p7)
}

func (s *IMultiSigStruct) MsigCreate(p0 context.Context, p1 uint64, p2 []address.Address, p3 abi.ChainEpoch, p4 chain.BigInt, p5 address.Address, p6 chain.BigInt) (*messagepool.MessagePrototype, error) {
	return s.Internal.MsigCreate(p0, p1, p2, p3, p4, p5, p6)
}

func (s *IMultiSigStruct) MsigGetVested(p0 context.Context, p1 address.Address, p2 chain.TipSetKey, p3 chain.TipSetKey) (chain.BigInt, error) {
	return s.Internal.MsigGetVested(p0, p1, p2, p3)
}

func (s *IMultiSigStruct) MsigPropose(p0 context.Context, p1 address.Address, p2 address.Address, p3 chain.BigInt, p4 address.Address, p5 uint64, p6 []byte) (*messagepool.MessagePrototype, error) {
	return s.Internal.MsigPropose(p0, p1, p2, p3, p4, p5, p6)
}

func (s *IMultiSigStruct) MsigRemoveSigner(p0 context.Context, p1 address.Address, p2 address.Address, p3 address.Address, p4 bool) (*messagepool.MessagePrototype, error) {
	return s.Internal.MsigRemoveSigner(p0, p1, p2, p3, p4)
}

func (s *IMultiSigStruct) MsigSwapApprove(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 address.Address, p6 address.Address) (*messagepool.MessagePrototype, error) {
	return s.Internal.MsigSwapApprove(p0, p1, p2, p3, p4, p5, p6)
}

func (s *IMultiSigStruct) MsigSwapCancel(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 address.Address) (*messagepool.MessagePrototype, error) {
	return s.Internal.MsigSwapCancel(p0, p1, p2, p3, p4, p5)
}

func (s *IMultiSigStruct) MsigSwapPropose(p0 context.Context, p1 address.Address, p2 address.Address, p3 address.Address, p4 address.Address) (*messagepool.MessagePrototype, error) {
	return s.Internal.MsigSwapPropose(p0, p1, p2, p3, p4)
}

type INetworkStruct struct {
	Internal struct {
		NetAddrsListen func(p0 context.Context) (peer.AddrInfo, error) `perm:"read"`

		NetworkConnect func(p0 context.Context, p1 []string) (<-chan net.ConnectionResult, error) `perm:"read"`

		NetworkFindPeer func(p0 context.Context, p1 peer.ID) (peer.AddrInfo, error) `perm:"read"`

		NetworkFindProvidersAsync func(p0 context.Context, p1 cid.Cid, p2 int) <-chan peer.AddrInfo `perm:"read"`

		NetworkGetBandwidthStats func(p0 context.Context) metrics.Stats `perm:"admin"`

		NetworkGetClosestPeers func(p0 context.Context, p1 string) ([]peer.ID, error) `perm:"read"`

		NetworkGetPeerAddresses func(p0 context.Context) []ma.Multiaddr `perm:"admin"`

		NetworkGetPeerID func(p0 context.Context) peer.ID `perm:"admin"`

		NetworkPeers func(p0 context.Context, p1 bool, p2 bool, p3 bool) (*net.SwarmConnInfos, error) `perm:"read"`

		Version func(p0 context.Context) (chain2.Version, error) `perm:"read"`
	}
}

func (s *INetworkStruct) NetAddrsListen(p0 context.Context) (peer.AddrInfo, error) {
	return s.Internal.NetAddrsListen(p0)
}

func (s *INetworkStruct) NetworkConnect(p0 context.Context, p1 []string) (<-chan net.ConnectionResult, error) {
	return s.Internal.NetworkConnect(p0, p1)
}

func (s *INetworkStruct) NetworkFindPeer(p0 context.Context, p1 peer.ID) (peer.AddrInfo, error) {
	return s.Internal.NetworkFindPeer(p0, p1)
}

func (s *INetworkStruct) NetworkFindProvidersAsync(p0 context.Context, p1 cid.Cid, p2 int) <-chan peer.AddrInfo {
	return s.Internal.NetworkFindProvidersAsync(p0, p1, p2)
}

func (s *INetworkStruct) NetworkGetBandwidthStats(p0 context.Context) metrics.Stats {
	return s.Internal.NetworkGetBandwidthStats(p0)
}

func (s *INetworkStruct) NetworkGetClosestPeers(p0 context.Context, p1 string) ([]peer.ID, error) {
	return s.Internal.NetworkGetClosestPeers(p0, p1)
}

func (s *INetworkStruct) NetworkGetPeerAddresses(p0 context.Context) []ma.Multiaddr {
	return s.Internal.NetworkGetPeerAddresses(p0)
}

func (s *INetworkStruct) NetworkGetPeerID(p0 context.Context) peer.ID {
	return s.Internal.NetworkGetPeerID(p0)
}

func (s *INetworkStruct) NetworkPeers(p0 context.Context, p1 bool, p2 bool, p3 bool) (*net.SwarmConnInfos, error) {
	return s.Internal.NetworkPeers(p0, p1, p2, p3)
}

func (s *INetworkStruct) Version(p0 context.Context) (chain2.Version, error) {
	return s.Internal.Version(p0)
}

type IPaychanStruct struct {
	Internal struct {
		PaychAllocateLane func(p0 context.Context, p1 address.Address) (uint64, error) `perm:"sign"`

		PaychAvailableFunds func(p0 context.Context, p1 address.Address) (*chain2.ChannelAvailableFunds, error) `perm:"sign"`

		PaychAvailableFundsByFromTo func(p0 context.Context, p1 address.Address, p2 address.Address) (*chain2.ChannelAvailableFunds, error) `perm:"sign"`

		PaychCollect func(p0 context.Context, p1 address.Address) (cid.Cid, error) `perm:"sign"`

		PaychGet func(p0 context.Context, p1 address.Address, p2 address.Address, p3 big.Int) (*paych.ChannelInfo, error) `perm:"sign"`

		PaychGetWaitReady func(p0 context.Context, p1 cid.Cid) (address.Address, error) `perm:"sign"`

		PaychList func(p0 context.Context) ([]address.Address, error) `perm:"read"`

		PaychNewPayment func(p0 context.Context, p1 address.Address, p2 address.Address, p3 []paych.VoucherSpec) (*paych.PaymentInfo, error) `perm:"sign"`

		PaychSettle func(p0 context.Context, p1 address.Address) (cid.Cid, error) `perm:"sign"`

		PaychStatus func(p0 context.Context, p1 address.Address) (*paych.Status, error) `perm:"read"`

		PaychVoucherAdd func(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher, p3 []byte, p4 big.Int) (big.Int, error) `perm:"write"`

		PaychVoucherCheckSpendable func(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher, p3 []byte, p4 []byte) (bool, error) `perm:"read"`

		PaychVoucherCheckValid func(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher) error `perm:"read"`

		PaychVoucherCreate func(p0 context.Context, p1 address.Address, p2 big.Int, p3 uint64) (*paych.VoucherCreateResult, error) `perm:"sign"`

		PaychVoucherList func(p0 context.Context, p1 address.Address) ([]*paych.SignedVoucher, error) `perm:"write"`

		PaychVoucherSubmit func(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher, p3 []byte, p4 []byte) (cid.Cid, error) `perm:"sign"`
	}
}

func (s *IPaychanStruct) PaychAllocateLane(p0 context.Context, p1 address.Address) (uint64, error) {
	return s.Internal.PaychAllocateLane(p0, p1)
}

func (s *IPaychanStruct) PaychAvailableFunds(p0 context.Context, p1 address.Address) (*chain2.ChannelAvailableFunds, error) {
	return s.Internal.PaychAvailableFunds(p0, p1)
}

func (s *IPaychanStruct) PaychAvailableFundsByFromTo(p0 context.Context, p1 address.Address, p2 address.Address) (*chain2.ChannelAvailableFunds, error) {
	return s.Internal.PaychAvailableFundsByFromTo(p0, p1, p2)
}

func (s *IPaychanStruct) PaychCollect(p0 context.Context, p1 address.Address) (cid.Cid, error) {
	return s.Internal.PaychCollect(p0, p1)
}

func (s *IPaychanStruct) PaychGet(p0 context.Context, p1 address.Address, p2 address.Address, p3 big.Int) (*paych.ChannelInfo, error) {
	return s.Internal.PaychGet(p0, p1, p2, p3)
}

func (s *IPaychanStruct) PaychGetWaitReady(p0 context.Context, p1 cid.Cid) (address.Address, error) {
	return s.Internal.PaychGetWaitReady(p0, p1)
}

func (s *IPaychanStruct) PaychList(p0 context.Context) ([]address.Address, error) {
	return s.Internal.PaychList(p0)
}

func (s *IPaychanStruct) PaychNewPayment(p0 context.Context, p1 address.Address, p2 address.Address, p3 []paych.VoucherSpec) (*paych.PaymentInfo, error) {
	return s.Internal.PaychNewPayment(p0, p1, p2, p3)
}

func (s *IPaychanStruct) PaychSettle(p0 context.Context, p1 address.Address) (cid.Cid, error) {
	return s.Internal.PaychSettle(p0, p1)
}

func (s *IPaychanStruct) PaychStatus(p0 context.Context, p1 address.Address) (*paych.Status, error) {
	return s.Internal.PaychStatus(p0, p1)
}

func (s *IPaychanStruct) PaychVoucherAdd(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher, p3 []byte, p4 big.Int) (big.Int, error) {
	return s.Internal.PaychVoucherAdd(p0, p1, p2, p3, p4)
}

func (s *IPaychanStruct) PaychVoucherCheckSpendable(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher, p3 []byte, p4 []byte) (bool, error) {
	return s.Internal.PaychVoucherCheckSpendable(p0, p1, p2, p3, p4)
}

func (s *IPaychanStruct) PaychVoucherCheckValid(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher) error {
	return s.Internal.PaychVoucherCheckValid(p0, p1, p2)
}

func (s *IPaychanStruct) PaychVoucherCreate(p0 context.Context, p1 address.Address, p2 big.Int, p3 uint64) (*paych.VoucherCreateResult, error) {
	return s.Internal.PaychVoucherCreate(p0, p1, p2, p3)
}

func (s *IPaychanStruct) PaychVoucherList(p0 context.Context, p1 address.Address) ([]*paych.SignedVoucher, error) {
	return s.Internal.PaychVoucherList(p0, p1)
}

func (s *IPaychanStruct) PaychVoucherSubmit(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher, p3 []byte, p4 []byte) (cid.Cid, error) {
	return s.Internal.PaychVoucherSubmit(p0, p1, p2, p3, p4)
}

type ISyncerStruct struct {
	Internal struct {
		ChainSyncHandleNewTipSet func(p0 context.Context, p1 *chain.ChainInfo) error `perm:"write"`

		ChainTipSetWeight func(p0 context.Context, p1 chain.TipSetKey) (big.Int, error) `perm:"read"`

		Concurrent func(p0 context.Context) int64 `perm:"read"`

		SetConcurrent func(p0 context.Context, p1 int64) error `perm:"admin"`

		StateCall func(p0 context.Context, p1 *chain.Message, p2 chain.TipSetKey) (*chain2.InvocResult, error) `perm:"read"`

		SyncState func(p0 context.Context) (*chain2.SyncState, error) `perm:"read"`

		SyncSubmitBlock func(p0 context.Context, p1 *chain.BlockMsg) error `perm:"write"`

		SyncerTracker func(p0 context.Context) *chain2.TargetTracker `perm:"read"`
	}
}

func (s *ISyncerStruct) ChainSyncHandleNewTipSet(p0 context.Context, p1 *chain.ChainInfo) error {
	return s.Internal.ChainSyncHandleNewTipSet(p0, p1)
}

func (s *ISyncerStruct) ChainTipSetWeight(p0 context.Context, p1 chain.TipSetKey) (big.Int, error) {
	return s.Internal.ChainTipSetWeight(p0, p1)
}

func (s *ISyncerStruct) Concurrent(p0 context.Context) int64 {
	return s.Internal.Concurrent(p0)
}

func (s *ISyncerStruct) SetConcurrent(p0 context.Context, p1 int64) error {
	return s.Internal.SetConcurrent(p0, p1)
}

func (s *ISyncerStruct) StateCall(p0 context.Context, p1 *chain.Message, p2 chain.TipSetKey) (*chain2.InvocResult, error) {
	return s.Internal.StateCall(p0, p1, p2)
}

func (s *ISyncerStruct) SyncState(p0 context.Context) (*chain2.SyncState, error) {
	return s.Internal.SyncState(p0)
}

func (s *ISyncerStruct) SyncSubmitBlock(p0 context.Context, p1 *chain.BlockMsg) error {
	return s.Internal.SyncSubmitBlock(p0, p1)
}

func (s *ISyncerStruct) SyncerTracker(p0 context.Context) *chain2.TargetTracker {
	return s.Internal.SyncerTracker(p0)
}

type IWalletStruct struct {
	Internal struct {
		HasPassword func(p0 context.Context) bool `perm:"admin"`

		LockWallet func(p0 context.Context) error `perm:"admin"`

		SetPassword func(p0 context.Context, p1 []byte) error `perm:"admin"`

		UnLockWallet func(p0 context.Context, p1 []byte) error `perm:"admin"`

		WalletAddresses func(p0 context.Context) []address.Address `perm:"admin"`

		WalletBalance func(p0 context.Context, p1 address.Address) (abi.TokenAmount, error) `perm:"read"`

		WalletDefaultAddress func(p0 context.Context) (address.Address, error) `perm:"write"`

		WalletExport func(p0 context.Context, p1 address.Address, p2 string) (*wallet.KeyInfo, error) `perm:"admin"`

		WalletHas func(p0 context.Context, p1 address.Address) (bool, error) `perm:"write"`

		WalletImport func(p0 context.Context, p1 *wallet.KeyInfo) (address.Address, error) `perm:"admin"`

		WalletNewAddress func(p0 context.Context, p1 address.Protocol) (address.Address, error) `perm:"write"`

		WalletSetDefault func(p0 context.Context, p1 address.Address) error `perm:"write"`

		WalletSign func(p0 context.Context, p1 address.Address, p2 []byte, p3 wallet.MsgMeta) (*crypto.Signature, error) `perm:"sign"`

		WalletSignMessage func(p0 context.Context, p1 address.Address, p2 *chain.Message) (*chain.SignedMessage, error) `perm:"sign"`

		WalletState func(p0 context.Context) int `perm:"admin"`
	}
}

func (s *IWalletStruct) HasPassword(p0 context.Context) bool {
	return s.Internal.HasPassword(p0)
}

func (s *IWalletStruct) LockWallet(p0 context.Context) error {
	return s.Internal.LockWallet(p0)
}

func (s *IWalletStruct) SetPassword(p0 context.Context, p1 []byte) error {
	return s.Internal.SetPassword(p0, p1)
}

func (s *IWalletStruct) UnLockWallet(p0 context.Context, p1 []byte) error {
	return s.Internal.UnLockWallet(p0, p1)
}

func (s *IWalletStruct) WalletAddresses(p0 context.Context) []address.Address {
	return s.Internal.WalletAddresses(p0)
}

func (s *IWalletStruct) WalletBalance(p0 context.Context, p1 address.Address) (abi.TokenAmount, error) {
	return s.Internal.WalletBalance(p0, p1)
}

func (s *IWalletStruct) WalletDefaultAddress(p0 context.Context) (address.Address, error) {
	return s.Internal.WalletDefaultAddress(p0)
}

func (s *IWalletStruct) WalletExport(p0 context.Context, p1 address.Address, p2 string) (*wallet.KeyInfo, error) {
	return s.Internal.WalletExport(p0, p1, p2)
}

func (s *IWalletStruct) WalletHas(p0 context.Context, p1 address.Address) (bool, error) {
	return s.Internal.WalletHas(p0, p1)
}

func (s *IWalletStruct) WalletImport(p0 context.Context, p1 *wallet.KeyInfo) (address.Address, error) {
	return s.Internal.WalletImport(p0, p1)
}

func (s *IWalletStruct) WalletNewAddress(p0 context.Context, p1 address.Protocol) (address.Address, error) {
	return s.Internal.WalletNewAddress(p0, p1)
}

func (s *IWalletStruct) WalletSetDefault(p0 context.Context, p1 address.Address) error {
	return s.Internal.WalletSetDefault(p0, p1)
}

func (s *IWalletStruct) WalletSign(p0 context.Context, p1 address.Address, p2 []byte, p3 wallet.MsgMeta) (*crypto.Signature, error) {
	return s.Internal.WalletSign(p0, p1, p2, p3)
}

func (s *IWalletStruct) WalletSignMessage(p0 context.Context, p1 address.Address, p2 *chain.Message) (*chain.SignedMessage, error) {
	return s.Internal.WalletSignMessage(p0, p1, p2)
}

func (s *IWalletStruct) WalletState(p0 context.Context) int {
	return s.Internal.WalletState(p0)
}

package main

import (
	"bytes"
	"fmt"
	"github.com/golangci/gofmt/gofmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"io/fs"
	"io/ioutil"
	"log"
	"strings"
	"text/template"
)

func main() {
	if err := gen("./pkg/types/internal", "./pkg/types/types_gen.go"); err != nil {
		log.Fatal(err)
	}
}

func gen(from, out string) error {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, from, func(info fs.FileInfo) bool {
		return !strings.HasSuffix(info.Name(), "_test.go")
	}, parser.AllErrors|parser.ParseComments)
	if err != nil {
		return err
	}
	visitor := &Visitor{}
	for _, pkg := range pkgs {
		for _, f := range pkg.Files {
			ast.Walk(visitor, f)
		}

	}

	buff := bytes.NewBufferString("")
	err = doTemplate(buff, visitor, `// Code generated by github.com/filecoin-project/tools/gen/api. DO NOT EDIT.

package types
import "github.com/filecoin-project/venus/pkg/types/internal"

//type redefine
{{range .Types}}type {{.}} = internal.{{.}}
{{end}}
//func redefine
{{range .Funcs}}var {{.}} = internal.{{.}}
{{end}}
//value redefine
{{range .Values}}var {{.}} = internal.{{.}}
{{end}}
`)
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(out, buff.Bytes(), 0777)
	if err != nil {
		return err
	}

	dff, err := gofmt.Run(out, true)
	if err != nil {
		return err
	}
	fmt.Println(string(dff))
	return nil
}

type Visitor struct {
	Types  []string
	Funcs  []string
	Values []string
}

func (v *Visitor) Visit(node ast.Node) ast.Visitor {
	switch t := node.(type) {
	case *ast.TypeSpec:
		if t.Name.IsExported() {
			v.Types = append(v.Types, t.Name.String())
		}

	case *ast.FuncDecl:
		if t.Name.IsExported() && t.Recv == nil && !isTest(t.Name.String()) {
			v.Funcs = append(v.Funcs, t.Name.String())
		}
	case *ast.ValueSpec:
		if t.Names[0].IsExported() {
			v.Values = append(v.Values, t.Names[0].String())
		}
	}

	return v
}

func isTest(str string) bool {
	return strings.HasPrefix(str, "Test")
}
func doTemplate(w io.Writer, info interface{}, templ string) error {
	t := template.Must(template.New("").
		Funcs(template.FuncMap{}).Parse(templ))
	return t.Execute(w, info)
}

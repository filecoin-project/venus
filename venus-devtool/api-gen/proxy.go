package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/printer"
	"io"
	"log"
	"path/filepath"
	"strings"

	"github.com/urfave/cli/v2"

	"github.com/filecoin-project/venus/venus-devtool/util"
)

var proxyCmd = &cli.Command{
	Name:  "proxy",
	Flags: []cli.Flag{},
	Action: func(cctx *cli.Context) error {
		if err := util.LoadExtraInterfaceMeta(); err != nil {
			return err
		}
		for _, target := range apiTargets {
			err := genProxyForAPI(target)
			if err != nil {
				log.Fatalf("got error while generating proxy codes for %s: %s", target.Type, err)
			}
		}
		return nil
	},
}

func genProxyForAPI(t util.APIMeta) error {
	opt := t.ParseOpt
	opt.ResolveImports = true
	ifaceMetas, astMeta, err := util.ParseInterfaceMetas(opt)
	if err != nil {
		return err
	}

	ifaceMap := map[string]*util.InterfaceMeta{}
	done := map[string]struct{}{}
	deps := map[string]util.ImportMeta{}

	for i := range ifaceMetas {
		ifaceMeta := ifaceMetas[i]
		ifaceMap[ifaceMeta.Name] = ifaceMeta
	}

	apiName := t.Type.Name()
	api, has := ifaceMap[apiName]
	if !has {
		return fmt.Errorf("api %s not found", apiName)
	}

	var contentBuffer bytes.Buffer

	err = writeForInterface(apiName, astMeta, ifaceMap, deps, done, &contentBuffer)
	if err != nil {
		return fmt.Errorf("gen for api interface %s: %w", apiName, err)
	}

	var fileBuffer bytes.Buffer

	fmt.Fprintf(&fileBuffer, "// Code generated by github.com/filecoin-project/venus/venus-devtool/api-gen. DO NOT EDIT.\npackage %s\n\n", api.Pkg.Name)

	err = writeImports(deps, &fileBuffer)
	if err != nil {
		return fmt.Errorf("gen imports: %w", err)
	}

	_, err = io.Copy(&fileBuffer, &contentBuffer)
	if err != nil {
		return fmt.Errorf("copy contents into output: %w", err)
	}

	return outputSourceFile(astMeta.Location, "proxy_gen.go", &fileBuffer)
}

func writeImports(deps map[string]util.ImportMeta, dst *bytes.Buffer) error {
	imports := [3][][2]string{}

	for iname, imeta := range deps {
		alias := ""
		base := filepath.Base(imeta.Path)
		if iname != base {
			alias = iname
		}

		imp := [2]string{alias, imeta.Path}
		idx := 0
		if !imeta.IsStd {
			idx++
			if strings.HasPrefix(imeta.Path, "github.com/filecoin-project/venus/") {
				idx++
			}
		}

		imports[idx] = append(imports[idx], imp)

	}

	fmt.Fprintln(dst, "import (")
	for _, impGroup := range imports {
		for _, imp := range impGroup {
			_, err := fmt.Fprintf(dst, "\t%s \"%s\"\n", imp[0], imp[1])
			if err != nil {
				return fmt.Errorf("write import for %#v: %w", imp, err)
			}
		}

		fmt.Fprintln(dst, "")
	}

	fmt.Fprintln(dst, ")")
	return nil
}

func writeForInterface(name string, astMeta *util.ASTMeta, ifaces map[string]*util.InterfaceMeta, deps map[string]util.ImportMeta, done map[string]struct{}, dst *bytes.Buffer) error {
	if _, has := done[name]; has {
		return nil
	}

	iface, has := ifaces[name]
	if !has {
		return fmt.Errorf("%s not found", name)
	}

	for _, nested := range iface.Nested {
		if err := writeForInterface(nested, astMeta, ifaces, deps, done, dst); err != nil {
			return fmt.Errorf("gen nested interface for %s: %w", name, err)
		}
	}

	if err := writeStruct(dst, iface, astMeta); err != nil {
		return fmt.Errorf("gen struct for %s: %w", name, err)
	}

	if err := writeMethods(dst, iface, astMeta, deps); err != nil {
		return fmt.Errorf("gen methods for %s: %w", name, err)
	}

	done[name] = struct{}{}
	return nil
}

const (
	structHeadFormat = `
type %s struct {
`

	structTail = `
}

`

	structInternalHead = `
	Internal struct {
`

	structInternalTail = `
	}
`
)

func writeStruct(dst *bytes.Buffer, ifaceMeta *util.InterfaceMeta, astMeta *util.ASTMeta) error {
	fmt.Fprintf(dst, structHeadFormat, structName(ifaceMeta.Name))

	for _, nested := range ifaceMeta.Nested {
		fmt.Fprintf(dst, "\t%s\n", structName(nested))
	}

	tmpBuf := &bytes.Buffer{}
	if len(ifaceMeta.Defined) > 0 {
		fmt.Fprint(dst, structInternalHead)

		for _, meth := range ifaceMeta.Defined {
			fmt.Fprintf(dst, "\t\t%s ", meth.Name)

			err := printer.Fprint(tmpBuf, astMeta.FileSet, meth.FuncType)
			if err != nil {
				return fmt.Errorf("write func %s: %w", meth.Name, err)
			}

			dst.WriteString(strings.ReplaceAll(tmpBuf.String(), "\n\t", ""))
			tmpBuf.Reset()

			fmt.Fprintf(dst, " `perm:\"%s\"`\n", util.GetAPIMethodPerm(meth))
		}

		fmt.Fprint(dst, structInternalTail)
	}

	fmt.Fprint(dst, structTail)
	return nil
}

func writeMethods(dst *bytes.Buffer, ifaceMeta *util.InterfaceMeta, astMeta *util.ASTMeta, deps map[string]util.ImportMeta) error {
	var typBuf bytes.Buffer
	for _, meth := range ifaceMeta.Defined {
		err := writeMethodBody(dst, &typBuf, ifaceMeta, meth, astMeta, deps)
		if err != nil {
			return fmt.Errorf("write method for %s.%s: %w", ifaceMeta.Name, meth.Name, err)
		}
	}
	fmt.Fprintln(dst, "")
	return nil
}

func resolveDep(typ ast.Expr, ifaceMeta *util.InterfaceMeta, deps map[string]util.ImportMeta) error {
	var selector *ast.SelectorExpr

	switch t := typ.(type) {
	case *ast.Ident:
		return nil

	case *ast.SelectorExpr:
		selector = t

	case *ast.MapType:
		if err := resolveDep(t.Key, ifaceMeta, deps); err != nil {
			return fmt.Errorf("resolve key dep for type %T: %w", typ, err)
		}

		if err := resolveDep(t.Value, ifaceMeta, deps); err != nil {
			return fmt.Errorf("resolve value dep for type %T: %w", typ, err)
		}

		return nil

	case *ast.ArrayType:
		if err := resolveDep(t.Elt, ifaceMeta, deps); err != nil {
			return fmt.Errorf("resolve element dep for type %T: %w", typ, err)
		}

		return nil

	case *ast.ChanType:
		if err := resolveDep(t.Value, ifaceMeta, deps); err != nil {
			return fmt.Errorf("resolve chan value dep for type %T: %w", typ, err)
		}

		return nil

	case *ast.StarExpr:
		if err := resolveDep(t.X, ifaceMeta, deps); err != nil {
			return fmt.Errorf("resolve ptr dep for type %T: %w", typ, err)
		}

		return nil

	default:
		return fmt.Errorf("found unexpected type: %T", typ)
	}

	if selector == nil {
		return fmt.Errorf("should be a *ast.SelectorExpr, found %T", typ)
	}

	selector, ok := typ.(*ast.SelectorExpr)
	if !ok {
		return nil
	}

	xident, ok := selector.X.(*ast.Ident)
	if !ok || xident.Name == "" {
		return nil
	}

	importMeta, has := ifaceMeta.File.Imports[xident.Name]
	if !has {
		return fmt.Errorf("package for selector %s not found in file %s", xident.Name, ifaceMeta.File.Name)
	}

	prev, has := deps[xident.Name]
	if !has {
		deps[xident.Name] = importMeta
		return nil
	}

	if prev.Path != importMeta.Path {
		return fmt.Errorf("found duplicate package name %s for %s and %s", xident.Name, prev.Path, importMeta.Path)
	}

	return nil
}

func writeMethodBody(dst *bytes.Buffer, typBuf *bytes.Buffer, ifaceMeta *util.InterfaceMeta, methMeta util.InterfaceMethodMeta, astMeta *util.ASTMeta, deps map[string]util.ImportMeta) error {
	paramNum := 0
	callNames := []string{}
	params := []string{}
	for pi, paramList := range methMeta.FuncType.Params.List {
		if err := resolveDep(paramList.Type, ifaceMeta, deps); err != nil {
			return fmt.Errorf("resolve dep for #%d param: %w", pi, err)
		}

		typBuf.Reset()
		err := printer.Fprint(typBuf, astMeta.FileSet, paramList.Type)
		if err != nil {
			return fmt.Errorf("write #%d param type: %w", pi, err)
		}

		nameCount := len(paramList.Names)
		if nameCount == 0 {
			nameCount = 1
		}

		names := make([]string, nameCount)
		for i := range names {
			names[i] = fmt.Sprintf("p%d", paramNum)
			paramNum++
		}

		callNames = append(callNames, names...)
		params = append(params, strings.Join(names, ", ")+" "+strings.ReplaceAll(typBuf.String(), "\n\t", ""))
	}

	results := []string{}
	for ri, resultList := range methMeta.FuncType.Results.List {
		if err := resolveDep(resultList.Type, ifaceMeta, deps); err != nil {
			return fmt.Errorf("resolve dep for #%d result: %w", ri, err)
		}

		typBuf.Reset()
		err := printer.Fprint(typBuf, astMeta.FileSet, resultList.Type)
		if err != nil {
			return fmt.Errorf("write #%d result type: %w", ri, err)
		}

		count := len(resultList.Names)
		if count == 0 {
			count = 1
		}

		for i := 0; i < count; i++ {
			results = append(results, strings.ReplaceAll(typBuf.String(), "\n\t", ""))
		}
	}

	sname := structName(ifaceMeta.Name)
	fmt.Fprintf(dst, "func(s *%s) %s(%s) (%s) { return s.Internal.%s(%s) }\n", sname, methMeta.Name, strings.Join(params, ", "), strings.Join(results, ", "), methMeta.Name, strings.Join(callNames, ", "))
	return nil
}
